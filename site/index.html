<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Shortest Path Algorithm with Heaps</title>
    <link rel="shortcut icon" href="./favicon.ico" />
    <link rel="stylesheet" href="./dist/reset.css" />
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/simple.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/monokai-sublime.css" />

    <link rel="stylesheet" href="./assets/custom.css" />
    <link rel="stylesheet" href="./assets/dark.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section data-markdown data-separator="<!--s-->" data-separator-vertical="<!--v-->">
          <textarea data-template>
            

<div class="middle center">
<div style="width: 100%">

# 音乐在频域上的可视化

<hr/>

By [胥涵坤](https://xiu-zju.me)



</div>
</div>

<!--s-->

<div class="middle center">
<div style="width: 100%">

# Part.0 引入



</div>
</div>


<!--v-->

## 效果图
你能看出来这是什么歌吗？

<center>

<img src="1.gif" alt="描述" width="700" height="400">

</center>

~~（当然你不可能看得出来~~

<hr/>



<!--v-->

## 我怎么想到这个主题的
~~万恶的短学期课程（划掉~~
<center>
<img src="2.gif" alt="描述" width="700" height="350">
</center>


<!--s-->

<div class="middle center">
<div style="width: 100%">

# Part.1 原理讲解

</div>
</div>

<!--v-->

## 从正弦波到方波

正弦波大家都见过，就是$\sin$，$\cos$，这里统称正弦波。那么有没有想过，方波是什么样子的？如果你学过傅里叶变换，那么下意识的反应，方波是频率不同的正弦波的叠加。但是你要没有学过也没有关系，简单的来说，不同的正弦波(有不同的频率，不同的幅度，不同的相位，正弦波的三要素)可以组合出来方波。

<center>
<img src="Fourier_transform.gif" alt="描述" width="600" height="300">
</center>

<!--v-->

## 任意信号的分解

看过了上面的方波例子，信号其实可以被分解为频率不同的正弦波的叠加。然后将频率看作一个轴(将$f$看作$x$轴)，不同的频率的正弦波信号所占总信号的比例就用垂直于频率轴的一个轴可以进行表示(将他看作$y$轴)。这样我们就有了平时在音乐播放器中所看见的频谱。而这个频谱就是我们要可视化的东西。

<center>
<img src="images.jpg" alt="描述" width="500" height="250">
</center>

<!--v-->
## 时域信号变频域信号
音频通常以时间为自变量表示，即$y=f(t)$，其中$t$表示时间，$y$表示该时刻的音量强度，这就是时域信号。相对地，频域信号表示为$z=g(f)$，其中$f$是频率，$z$表示某频率的信号成分大小，也可以理解为该信号与对应频率的正弦波相似度。相似度越高，表明该频率成分越强。

如何将$f(t)$变成$g(f)$呢？这里用到的是就是傅里叶变换。

<center>
<img src="sa1jpkljil.gif" alt="描述" width="500" height="250">

</center>

<!--v-->
## 如何用计算机实现
计算机是二进制的，所以计算机只能处理离散的数据，所以将我们上面的东西迁移一下:我们的频域信号，也就是我们所要可视化的东西，变成了一串数据。此时下标代表的其实是频率。那么将时域变成频域的函数，就变成了fft(快速傅里叶变换)。
<center>
<img src="discrete.jpg" alt="描述" width="500" height="250">

离散数据

</center>

<!--v-->

<div class="middle center">
<div style="width: 100%">

# 理论存在，实践开始！
<!--s-->

<div class="middle center">
<div style="width: 100%">

# Part.2 具体实现


<!--v-->

## 问题分解

这次要实现的东西主要实现音频播放时进行实时计算，然后将实时频域的图像绘制出来。对应此次任务就可以分解为三个部分，

1. 将音频播放出来，并可以实时读取播放的音频时域数据
2. 将拿到数据进行实时fft
3. 将fft的数据绘制出来


语言选择：
Python （伟大！

<center>
<img src="download.png" alt="描述" width="200" height="200">
</center>



<!--v-->

## 任务一
```python
#音频流回调函数，会在音频chunk播放完后调用
def callback(indata, outdata, frames, time, status):
    frames = chunk_size #每次给流内推入chunk_size个数据
    global sound_chunk_idx
    #下面的if语句用来判断最后的音频不够chunk_size个值，防止程序出错
    if (music_data[chunk_size*sound_chunk_idx:chunk_size*(sound_chunk_idx+1), 0].size < chunk_size):
        raise sd.CallbackStop()
        return
    #推入流
    outdata[:] = music_data[chunk_size*sound_chunk_idx:chunk_size*(sound_chunk_idx+1), :]
    sound_chunk_idx += 1;
    #改变buffer, 生成动画
    buffer[:] = np.abs(fft(outdata[0:1024, 0]))[:512:8]
```
这里使用sounddevice这个库，通过Stream的方式进行播放，拿到实时的音频数据。你可以将音频想象成水，然后喇叭在河的下游，然后你将水(音频流)不断倒到河道中就可以让喇叭发出声音。

<!--v-->

## 任务二

这步比较简单，就是将时域数据通过fft变成频域数据。你会看到，这里有个buffer变量，它是一个全局变量，保存频域的实时数据，给后面绘图用。接下来，用到abs函数，这是因为数据转换后是复数，我们需要用abs取复数的模值，这样就能得到对应的能量大小。

```python
buffer[:] = np.abs(fft(outdata[0:1024, 0]))[:512:8]
```

<center>
<img src="fft.jpg" alt="描述" width="500" height="250">
</center>

<!--v-->
## 任务三

绘图。使用了matplotlib这个绘图库。基本思路是让matplotlib调用函数不断绘图，绘图的依据就是前面提到过buffer，通过播放时不断更新buffer中的值就可以变成实时频谱图了。

```python
fig, ax = plt.subplots(figsize=(18,9)) #画图的对象
ax.axis('off') #关闭坐标轴和边框
#初始化函数，第一帧
def init():
    ax.set_xlim(1, 65) #横轴的标
    ax.set_ylim(0, 3000000) #纵轴的坐标
    return ax.stem(buffer, buffer)
#更新函数，会在动画的每一帧调用
def update(frame):
    xdata = np.arange(1, 65) #共有65个数据点
    ydata = buffer #通过callback函数来改变buffer的值，然后让频谱动起来
    b_c = ax.stem(xdata, ydata, linefmt='--', markerfmt=None) #这里这里stem图
    return b_c #必须有
ani = FuncAnimation(fig, update, init_func=init, interval=20, blit=True)
plt.show(block=False)
```

<!--s-->

<div class="middle center">
<div style="width: 100%">

# 最终效果
全体欣赏音乐！！！

<!--s-->

<div class="middle center">
<div style="width: 100%">

# 谢谢！
<hr/>

By [胥涵坤](https://xiu-zju.me)
          </textarea>
        </section>
      </div>
    </div>   
    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        slideNumber: true,
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath.KaTeX
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide","transitionSpeed":"fast","center":false,"slideNumber":"c/t","width":1000,"_":["dark.md"],"scripts":"https://cdn.tonycrane.cc/heti/heti.js,heti_worker.js","template":"template.html","static":"../site","assets-dir":"assets","assetsDir":"assets"}, queryOptions);
    </script>

    <script src="https://cdn.tonycrane.cc/heti/heti.js"></script>
    <script src="./assets/heti_worker.js"></script>

    <script>
      Reveal.initialize(options).then(() => {
        document.querySelector(".backgrounds").setAttribute("style", document.querySelector(".slides").style.cssText);
      });
      Reveal.on('overviewshown', event => {
        document.querySelector(".backgrounds").setAttribute("style", "");
      });
      Reveal.on('overviewhidden', event => {
        document.querySelector(".backgrounds").setAttribute("style", document.querySelector(".slides").style.cssText);
      });
      Reveal.on('resize', event => {
        document.querySelector(".backgrounds").setAttribute("style", document.querySelector(".slides").style.cssText);
      });
    </script>
  </body>
</html>
